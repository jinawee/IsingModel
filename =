#!/usr/bin/env python 
# -*- coding: utf-8 -*-

from __future__ import division
import numpy as np
from random import choice, random, randint
from pylab import imshow, figure, grid, show
#CTES
#k=1.38e-23;
k=1
T=0.1;
J=1;

def buildsystem(m): #optimizar
  system=np.empty([m,m])
  for i in range(m):
    for j in range (m):
      system[i,j]=choice([1,-1])
  return system

def flips(dE):
  P=np.exp(-dE/(k*T))
  x=random()
  if x>P: return 1
  return 0

def energyvar(spin, neighbors):
  dE=-2*J*spin*sum(neighbors)
  return dE

def bc(i):
    if i+1 > SIZE-1:
        return 0
    if i-1 < 0:
        return SIZE-1
    else:
        return i

def getneighbors(system,i,j): #simplificar con cuatro llamadas boundarycond
  #m=len(system)-1
  #up=i-1; down=i+1; left=j-1; right=j+1
  #if up<0: sup=system[m,j]
  #else: sup=system[up,j]
  #if down>m: sdown=system[0,j]
  #else: sdown=system[down,j]
  #if left<0: sleft=system[i,m]
  #else: sleft=system[i,left]
  #if right>m: sright=system[i,0]
  #else: sright=system[i,right]
  #s=system
  #return [sup, sdown, sleft, sright]

  return [s[bc(i+1),j],s[bc(i-1),j],s[i,bc(j+1)],s[i,bc(j-1)]]

def loop(system,nit):
  m=len(system)-1
  for n in range(nit):
    i=randint(0,m)
    j=randint(0,m)
    neighbors=getneighbors(system,i,j)
    dE=energyvar(system[i,j],neighbors)
    if dE<=0:
      system[i,j]*=-1
    elif flips(dE):
      system[i,j]*=-1
  return system

system=buildsystem(150)
SIZE=150
final=loop(system,int(1e5))
figure(2)
imshow(final, interpolation='nearest')
grid(True)
show()
